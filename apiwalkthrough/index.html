<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>API Walkthrough &#8212; loompy 2.0.16 documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Cookbook" href="../cookbook/index.html" />
    <link rel="prev" title="Understanding the semantics of loom files" href="../semantics/index.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head><body>

  <div id="navbar" class="navbar navbar-light navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/Loom_icon.png"></span>
          Loom</a>
        <span class="navbar-text navbar-version pull-left"><b>2.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="http://loompy.org">loompy.org</a></li>
                <li><a href="https://github.com/linnarsson-lab/loompy">GitHub</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Contents <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Loompy documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation/index.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../installation/index.html#requirements">Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation/index.html#easy-installation">Easy installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation/index.html#from-source">From source</a></li>
<li class="toctree-l2"><a class="reference internal" href="../installation/index.html#getting-started">Getting Started</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../semantics/index.html">Understanding the semantics of loom files</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../semantics/index.html#connecting-not-loading-and-saving">Connecting, not loading and saving</a></li>
<li class="toctree-l2"><a class="reference internal" href="../semantics/index.html#reading-and-writing">Reading and writing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../semantics/index.html#efficient-indexing-and-compression">Efficient indexing and compression</a></li>
<li class="toctree-l2"><a class="reference internal" href="../semantics/index.html#matrix-and-attributes">Matrix and attributes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../semantics/index.html#data-types">Data types</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Walkthrough</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#creating-and-connecting">Creating and connecting</a></li>
<li class="toctree-l2"><a class="reference internal" href="#manipulate-data">Manipulate data</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cookbook/index.html">Cookbook</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/index.html#working-with-a-newly-created-file">Working with a newly created file</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/index.html#loading-attributes-from-pandas">Loading attributes from Pandas</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/index.html#combining-data-using-scan-and-new">Combining data using scan() and new()</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cookbook/index.html#fitting-an-incremental-pca">Fitting an incremental PCA</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../conventions/index.html">Conventions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../conventions/index.html#single-analysis-per-file">Single analysis per file</a></li>
<li class="toctree-l2"><a class="reference internal" href="../conventions/index.html#orientation">Orientation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../conventions/index.html#attribute-naming-conventions">Attribute naming conventions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../format/index.html">Loom file format specs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../format/index.html#versions">Versions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../format/index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../format/index.html#hdf5-concepts">HDF5 concepts</a></li>
<li class="toctree-l2"><a class="reference internal" href="../format/index.html#specification">Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../format/index.html#datatypes">Datatypes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../format/index.html#example">Example</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../fullapi/index.html">Complete API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../fullapi/create.html">create (function)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fullapi/new.html">new (function)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fullapi/create_from_cellranger.html">create_from_cellranger (function)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fullapi/connect.html">connect (function)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fullapi/combine.html">combine (function)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fullapi/loompy.html">LoomConnection (class)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fullapi/layer_manager.html">LayerManager (class)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fullapi/memory_loom_layer.html">MemoryLoomLayer (class)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fullapi/loom_layer.html">LoomLayer (class)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fullapi/view_manager.html">ViewManager (class)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fullapi/loom_view.html">LoomView (class)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fullapi/loom_validator.html">LoomValidator (class)</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary"><div class="list-group">
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Loompy documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation/index.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../semantics/index.html">Understanding the semantics of loom files</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Walkthrough</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#creating-and-connecting">Creating and connecting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#creating-loom-files">Creating Loom files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#connecting-to-loom-files">Connecting to Loom files</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#manipulate-data">Manipulate data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#shape-indexing-and-slicing">Shape, indexing and slicing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sparse-data">Sparse data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modifying-layers">Modifying layers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#global-attributes">Global attributes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#row-and-column-attributes">Row and column attributes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modifying-attributes">Modifying attributes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adding-columns">Adding columns</a></li>
<li class="toctree-l3"><a class="reference internal" href="#layers">Layers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#graphs">Graphs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#views">Views</a></li>
<li class="toctree-l3"><a class="reference internal" href="#operations">Operations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#map">Map</a></li>
<li class="toctree-l4"><a class="reference internal" href="#permutation">Permutation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scan">Scan</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cookbook/index.html">Cookbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../conventions/index.html">Conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../format/index.html">Loom file format specs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fullapi/index.html">Complete API Reference</a></li>
</ul>

</div>
        </div>
      </div>
    <div class="col-md-9 content">
      
  <div class="section" id="api-walkthrough">
<span id="apiwalkthrough"></span><h1>API Walkthrough<a class="headerlink" href="#api-walkthrough" title="Permalink to this headline">¶</a></h1>
<div class="section" id="creating-and-connecting">
<span id="loomcreate"></span><h2>Creating and connecting<a class="headerlink" href="#creating-and-connecting" title="Permalink to this headline">¶</a></h2>
<div class="section" id="creating-loom-files">
<h3>Creating Loom files<a class="headerlink" href="#creating-loom-files" title="Permalink to this headline">¶</a></h3>
<p>To create a loom file from data, you need to supply a main matrix (numpy ndarray or scipy sparse matrix) and two dictionaries of row and column attributes (with attribute names as keys, and numpy ndarrays as values). If the main matrix is N×M, then the row attributes must have N elements, and the column attributes must have M elements.</p>
<p>For example, the following creates a loom file with a 100x100 main matrix, one row attribute and one column attribute:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">loompy</span>
<span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;test.loom&quot;</span>
<span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">row_attrs</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;SomeRowAttr&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="p">}</span>
<span class="n">col_attrs</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;SomeColAttr&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="p">}</span>
<span class="n">loompy</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">row_attrs</span><span class="p">,</span> <span class="n">col_attrs</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="../fullapi/create.html#loompy.create" title="loompy.create"><code class="xref py py-func docutils literal notranslate"><span class="pre">loompy.create()</span></code></a> accepts numpy dense matrices (<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.15)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) as well as scipy sparse matrices (<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.coo_matrix.html#scipy.sparse.coo_matrix" title="(in SciPy v1.1.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.sparse.coo_matrix</span></code></a>,
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csc_matrix.html#scipy.sparse.csc_matrix" title="(in SciPy v1.1.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.sparse.csc_matrix</span></code></a>, or <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v1.1.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code></a>). For example:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">loompy</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sparse</span>
<span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;test.loom&quot;</span>
<span class="n">matrix</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="n">row_attrs</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;SomeRowAttr&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="p">}</span>
<span class="n">col_attrs</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;SomeColAttr&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="p">}</span>
<span class="n">loompy</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">row_attrs</span><span class="p">,</span> <span class="n">col_attrs</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that <a class="reference internal" href="../fullapi/create.html#loompy.create" title="loompy.create"><code class="xref py py-func docutils literal notranslate"><span class="pre">loompy.create()</span></code></a> does not return anything. To work with the newly created file, you must <a class="reference internal" href="../fullapi/connect.html#loompy.connect" title="loompy.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">loompy.connect()</span></code></a> to it.</p>
<p>You can also create an empty file using <a class="reference internal" href="../fullapi/new.html#loompy.new" title="loompy.new"><code class="xref py py-func docutils literal notranslate"><span class="pre">loompy.new()</span></code></a>, which returns a connection to the newly created file. The file can then be populated with data.
This is especially useful when you’re building a dataset incrementally, e.g. by pooling subsets of other datasets:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">loompy</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;outfile.loom&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">dsout</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">sample</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">loompy</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span> <span class="k">as</span> <span class="n">dsin</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Appending </span><span class="si">{sample}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="n">dsout</span><span class="o">.</span><span class="n">add_columns</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">layers</span><span class="p">,</span> <span class="n">col_attrs</span><span class="o">=</span><span class="n">dsin</span><span class="o">.</span><span class="n">col_attrs</span><span class="p">,</span> <span class="n">row_attrs</span><span class="o">=</span><span class="n">dsin</span><span class="o">.</span><span class="n">row_attrs</span><span class="p">)</span>
</pre></div>
</div>
<p>You can also create a file by combining existing loom files (<a class="reference internal" href="../fullapi/combine.html#loompy.combine" title="loompy.combine"><code class="xref py py-func docutils literal notranslate"><span class="pre">loompy.combine()</span></code></a>). The files will be concatenated along the column
axis, and therefore must have the same number of rows. If the rows are potentially not in the same order,
you can supply a <code class="docutils literal notranslate"><span class="pre">key</span></code> argument; the row attribute corresponding to the key will be used to sort the files.
For example, the following code will combine files and use the “Accession” row attribute as the key:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">loompy</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">output_filename</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;Accession&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>You can import a 10X Genomics
<a class="reference external" href="http://support.10xgenomics.com/single-cell/software/pipelines/latest/what-is-cell-ranger">cellranger</a>
output folder using <a class="reference internal" href="../fullapi/create_from_cellranger.html#loompy.create_from_cellranger" title="loompy.create_from_cellranger"><code class="xref py py-func docutils literal notranslate"><span class="pre">loompy.create_from_cellranger()</span></code></a>:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">loompy</span><span class="o">.</span><span class="n">create_from_cellranger</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="n">output_filename</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="connecting-to-loom-files">
<h3>Connecting to Loom files<a class="headerlink" href="#connecting-to-loom-files" title="Permalink to this headline">¶</a></h3>
<p>In order to work with a loom file, you must first <a class="reference internal" href="../fullapi/connect.html#loompy.connect" title="loompy.connect"><code class="xref py py-func docutils literal notranslate"><span class="pre">loompy.connect()</span></code></a> to it. This does not load the data
or attributes, so is very quick regardless of the size of the file. It’s more like connecting to a
database than reading a file. Loom supports Python context management, so normally you should use
a <code class="docutils literal notranslate"><span class="pre">with</span></code> statement to take care of the connection:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">loompy</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;filename.loom&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ds</span><span class="p">:</span>
  <span class="c1"># do something with ds</span>
</pre></div>
</div>
<p>The connection will be automatically closed at the end of the <code class="docutils literal notranslate"><span class="pre">with</span></code> block.</p>
<p>Sometimes, especially in interactive use in a Jupyter notebook, you may want
to just open the file and keep the connection around:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ds</span> <span class="o">=</span> <span class="n">loompy</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;filename.loom&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>In that case, you should close the file when you are done:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ds</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>In most cases, forgetting to close the file will do no harm, but may (for example)
prevent concurrent processes from accessing the file, and will leak file handles.</p>
<p>In the rest of the documentation below, <code class="docutils literal notranslate"><span class="pre">ds</span></code> is assumed to be an
instance of <a class="reference internal" href="../fullapi/loompy.html#loompy.loompy.LoomConnection" title="loompy.loompy.LoomConnection"><code class="xref py py-class docutils literal notranslate"><span class="pre">LoomConnection</span></code></a> obtained by connecting to a Loom
file.</p>
</div>
</div>
<div class="section" id="manipulate-data">
<span id="loommanipulate"></span><h2>Manipulate data<a class="headerlink" href="#manipulate-data" title="Permalink to this headline">¶</a></h2>
<div class="section" id="shape-indexing-and-slicing">
<h3>Shape, indexing and slicing<a class="headerlink" href="#shape-indexing-and-slicing" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../fullapi/loompy.html#loompy.loompy.LoomConnection.shape" title="loompy.loompy.LoomConnection.shape"><code class="xref py py-attr docutils literal notranslate"><span class="pre">LoomConnection.shape</span></code></a> attribute returns the row and column count as a tuple:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 2345)</span>
</pre></div>
</div>
<p>The data stored in the main matrix can be retrieved by indexing and
slicing. The following are supported:</p>
<ul class="simple">
<li>Indices: anything that can be converted to a Python long</li>
<li>Slices (i.e. <code class="docutils literal notranslate"><span class="pre">:</span></code> or <code class="docutils literal notranslate"><span class="pre">0:10</span></code>)</li>
<li>Lists of the rows/columns you want (i.e. <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">34,</span> <span class="pre">576]</span></code>)</li>
<li>Mask arrays (i.e. numpy array of bool indicating the rows/columns you
want)</li>
</ul>
<p>Lists and mask arrays are supported along one dimension at a time only. Since
the main matrix is two-dimensional, two arguments are always needed. Examples:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ds</span><span class="p">[:,</span> <span class="p">:]</span>          <span class="c1"># Return the entire matrix</span>
<span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>    <span class="c1"># Return the 10x10 submatrix starting at row and column zero</span>
<span class="n">ds</span><span class="p">[</span><span class="mi">99</span><span class="p">,</span> <span class="p">:]</span>         <span class="c1"># Return the 100th row</span>
<span class="n">ds</span><span class="p">[:,</span> <span class="mi">99</span><span class="p">]</span>         <span class="c1"># Return the 100th column</span>
<span class="n">ds</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="p">:]</span>    <span class="c1"># Return rows with index 0, 3 and 5</span>
<span class="n">ds</span><span class="p">[:,</span> <span class="n">bool_array</span><span class="p">]</span> <span class="c1"># Return columns where bool_array elements are True</span>
</pre></div>
</div>
<p>Note that performance will be poor if you select many individual rows (columns) out
of a large matrix. For example, in a dataset with shape (27998, 160796), loading ten
randomly chosen individual full columns took 914 ms,
whereas loading 1000 columns took 1 minute and 6 seconds, and loadingh 5000 columns took 13 minutes.
This slowdown is caused by a <a class="reference external" href="https://github.com/h5py/h5py/issues/293">performance bug</a>
in h5py.</p>
<p>If the whole dataset fits in RAM, loading it in full and then selecting the row/columns you want
will be faster. If it doesn’t, consider using the <code class="xref py py-func docutils literal notranslate"><span class="pre">LoomConnection.scan()</span></code> method (see below), which in this example took
1 minute and 12 seconds regardless of how many columns were selected. As a rule of thumb,
<code class="xref py py-func docutils literal notranslate"><span class="pre">LoomConnection.scan()</span></code> will be faster whenever you are loading more than about 1% of the rows
or columns (randomly selected).</p>
</div>
<div class="section" id="sparse-data">
<h3>Sparse data<a class="headerlink" href="#sparse-data" title="Permalink to this headline">¶</a></h3>
<p>On disk, every layer is stored chunked and block-compressed, for efficient storage and access along both axes.</p>
<p>The main matrix and additional layers can be assigned from dense or sparse matrices.</p>
<p>You can load the main matrix or any layer as sparse:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ds</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;exons&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sparse</span><span class="p">()</span>  <span class="c1"># Returns a scipy.sparse.coo_matrix</span>
<span class="n">ds</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;unspliced&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sparse</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)</span>  <span class="c1"># Returns only the indicated rows and columns (ndarrays of integers or bools)</span>
</pre></div>
</div>
<p>You can assign layers from sparse matrices:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ds</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;exons&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_sparse_matrix</span>
</pre></div>
</div>
</div>
<div class="section" id="modifying-layers">
<h3>Modifying layers<a class="headerlink" href="#modifying-layers" title="Permalink to this headline">¶</a></h3>
<p>You can modify the data in any layer by assigning to a slice. For example:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ds</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">newdata</span>         <span class="c1"># Assign a full matrix</span>
<span class="n">ds</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">500</span><span class="p">]</span> <span class="o">=</span> <span class="mi">31</span>            <span class="c1"># Set the element at (3, 500) to the value 31</span>
<span class="n">ds</span><span class="p">[</span><span class="mi">99</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">rowdata</span>        <span class="c1"># Assign new values to row with index 99</span>
<span class="n">ds</span><span class="p">[:,</span> <span class="mi">99</span><span class="p">]</span> <span class="o">=</span> <span class="n">coldata</span>        <span class="c1"># Assign new values to column with index 99</span>
</pre></div>
</div>
</div>
<div class="section" id="global-attributes">
<h3>Global attributes<a class="headerlink" href="#global-attributes" title="Permalink to this headline">¶</a></h3>
<p>Global attributes are available at <code class="docutils literal notranslate"><span class="pre">ds.attrs</span></code> and can be accessed by name or
as a dictionary. You create new attributes by assignment, and delete them
using the <code class="docutils literal notranslate"><span class="pre">del</span></code> statement:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">title</span>
<span class="go">&quot;The title of the dataset&quot;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;New title&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;title&quot;</span><span class="p">]</span>
<span class="go">&quot;New title&quot;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">title</span>
</pre></div>
</div>
<p>You can list the attributes and loop over them as you would with a dictionary:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="go">[&quot;title&quot;, &quot;description&quot;]</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{key}</span><span class="s2"> = </span><span class="si">{value}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="go">title = New title</span>
<span class="go">description = Fancy dataset</span>
</pre></div>
</div>
<p>Global attributes can be scalars, or multidimensional arrays of any shape, and
the elements can be integers, floats or strings. See below for the exact types allowed.</p>
</div>
<div class="section" id="row-and-column-attributes">
<h3>Row and column attributes<a class="headerlink" href="#row-and-column-attributes" title="Permalink to this headline">¶</a></h3>
<p>Row and column attributes are accessed at <code class="docutils literal notranslate"><span class="pre">ds.ra</span></code>
and <code class="docutils literal notranslate"><span class="pre">ds.ca</span></code>, respectively, and support the same interface as global
attributes. For example:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ds</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>       <span class="c1"># Return list of row attribute names</span>
<span class="n">ds</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>       <span class="c1"># Return list of column attribute names</span>
<span class="n">ds</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">Gene</span> <span class="o">=</span> <span class="o">...</span>   <span class="c1"># Create or replace the Gene attribute</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">Gene</span>     <span class="c1"># Assign the array of gene names (assuming the attribute exists)</span>
<span class="k">del</span> <span class="n">ds</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">Gene</span>     <span class="c1"># Delete the Gene row attribute</span>
</pre></div>
</div>
<p>Attributes can also be accessed by indexing:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">ra</span><span class="p">[</span><span class="s2">&quot;Gene&quot;</span><span class="p">]</span>     <span class="c1"># Assign the array of gene names (assuming the attribute exists)</span>
<span class="k">del</span> <span class="n">ds</span><span class="o">.</span><span class="n">ra</span><span class="p">[</span><span class="s2">&quot;Gene&quot;</span><span class="p">]</span>     <span class="c1"># Delete the Gene row attribute</span>
</pre></div>
</div>
<p>You can pick out multiple attributes into a single numpy array, as long as they have the same type:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">ra</span><span class="p">[</span><span class="s2">&quot;Gene&quot;</span><span class="p">,</span> <span class="s2">&quot;Attribute&quot;</span><span class="p">]</span>     <span class="c1"># Returns a 2D array of shape (n_genes, 2)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">ca</span><span class="p">[</span><span class="s2">&quot;PCA1&quot;</span><span class="p">,</span> <span class="s2">&quot;PCA2&quot;</span><span class="p">]</span>          <span class="c1"># Returns a 2D array of shape (n_cells, 2)</span>
</pre></div>
</div>
<p>Note that when you ask for multiple attributes, missing attributes are silently ignored. This can be
exploited to access attributes that may have different names:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">ra</span><span class="p">[</span><span class="s2">&quot;Gene&quot;</span><span class="p">,</span> <span class="s2">&quot;GeneName&quot;</span><span class="p">]</span>     <span class="c1"># Return one or the other (if only one exists)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">ca</span><span class="p">[</span><span class="s2">&quot;TSNE&quot;</span><span class="p">,</span> <span class="s2">&quot;PCA&quot;</span><span class="p">,</span> <span class="s2">&quot;UMAP&quot;</span><span class="p">]</span>  <span class="c1"># Return the one that exists (if only one exists)</span>
</pre></div>
</div>
<p>(of course, if two or more attributes exists, they will be stacked as above)</p>
<p>Attributes can be any of the following:</p>
<ul class="simple">
<li>One-dimensional arrays of integers, floats or strings. The number of elements in the array must match the corresponding matrix dimension.</li>
<li>Multidimensional arrays of any of the same element types. The length along the first dimension of a row attribute must equal the number of rows in the main matrix (and vice versa for column attributes). Remaining dimensions can be any size.</li>
</ul>
<p>For example, if the main matrix has M columns, the result of a dimensionality reduction
(for example, a PCA) to 20 dimensions could be stored as a column attribute with shape (M, 20).</p>
<p>You can assign attributes using almost any array or list-like type, but attributes will
always return numpy array (<code class="docutils literal notranslate"><span class="pre">np.ndarray</span></code>).</p>
<p>Using attributes as masks for indexing the main matrix results in a very compact and readable
syntax for selecting subarrays:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="p">[</span><span class="n">ds</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">Gene</span> <span class="o">==</span> <span class="s2">&quot;Actb&quot;</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">array([[  2.,   9.,   9., ...,   0.,  14.,   0.]], dtype=float32)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="p">[(</span><span class="n">ds</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">Gene</span> <span class="o">==</span> <span class="s2">&quot;Actb&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">ra</span><span class="o">.</span><span class="n">Gene</span> <span class="o">==</span> <span class="s2">&quot;Gapdh&quot;</span><span class="p">),</span> <span class="p">:]</span>
<span class="go">array([[  2.,   9.,   9., ...,   0.,  14.,   0.],</span>
<span class="go">       [  0.,   1.,   4., ...,   0.,  14.,   3.]], dtype=float32)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">ds</span><span class="p">[:,</span> <span class="n">ds</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">CellID</span> <span class="o">==</span> <span class="s2">&quot;AAACATACATTCTC-1&quot;</span><span class="p">]</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 0.],</span>
<span class="go">       [ 0.],</span>
<span class="go">       ...,</span>
<span class="go">       [ 0.],</span>
<span class="go">       [ 0.],</span>
<span class="go">       [ 0.]], dtype=float32)</span>
</pre></div>
</div>
<p>Note that numpy logical functions overload the bitwise, not the boolean operators. Use <code class="docutils literal notranslate"><span class="pre">|</span></code>
for ‘or’, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> for ‘and’ and <code class="docutils literal notranslate"><span class="pre">~</span></code> for ‘not’. You also must place parentheses around the comparison
expressions to ensure proper operator precedence. For example:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">|</span> <span class="o">~</span><span class="p">(</span><span class="n">c</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="modifying-attributes">
<h3>Modifying attributes<a class="headerlink" href="#modifying-attributes" title="Permalink to this headline">¶</a></h3>
<p>Unlike layers, attributes are always only read and written in their entirety. Thus, assigning to a slice
does not modify the attribute on disk. To write new values for an attribute, you must assign a
full list or ndarray to the attribute:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">loompy</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;filename.loom&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ds</span><span class="p">:</span>
  <span class="n">ds</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">ClusterNames</span> <span class="o">=</span> <span class="n">values</span>  <span class="c1"># where values is a list or ndarray with one element per column</span>
  <span class="c1"># This does not change the attribute on disk:</span>
  <span class="n">ds</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">ClusterNames</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;banana&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="adding-columns">
<h3>Adding columns<a class="headerlink" href="#adding-columns" title="Permalink to this headline">¶</a></h3>
<p>You can add columns to an existing loom file. It’s not possible to add rows or to
delete any part of the matrix.</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ds</span><span class="o">.</span><span class="n">add_columns</span><span class="p">(</span><span class="n">submatrix</span><span class="p">,</span> <span class="n">col_attrs</span><span class="p">)</span>
</pre></div>
</div>
<p>You need to provide a submatrix corresponding to the new columns, as well as
a dictionary of column attributes with values for all the new columns.</p>
<p>Note that if you are adding columns to an empty file, you must also provide row attributes:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ds</span><span class="o">.</span><span class="n">add_columns</span><span class="p">(</span><span class="n">submatrix</span><span class="p">,</span> <span class="n">col_attrs</span><span class="p">,</span> <span class="n">row_attrs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Gene&quot;</span><span class="p">:</span> <span class="n">genes</span><span class="p">})</span>
</pre></div>
</div>
<p>You can also add the contents of another .loom file:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ds</span><span class="o">.</span><span class="n">add_loom</span><span class="p">(</span><span class="n">other_file</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s2">&quot;Gene&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The content of the other file is added as columns on the right of the
current dataset. The rows must match for this to work. That is, the two
files must have exactly the same number of rows. If <code class="docutils literal notranslate"><span class="pre">key</span></code> is given, the
rows will be ordered based on the key attribute. Furthermore, the two
datasets must have the same column
attributes (but of course can have different <em>values</em> for those
attributes at each column). Missing attributes can be given default
values using the <code class="docutils literal notranslate"><span class="pre">fill_values</span></code> argument. If the files contain any global attribute
with conflicting values, you can automatically convert such attributes into column attributes
by passing <code class="docutils literal notranslate"><span class="pre">convert_attrs=True</span></code> to the method.</p>
</div>
<div class="section" id="layers">
<span id="loomlayers"></span><h3>Layers<a class="headerlink" href="#layers" title="Permalink to this headline">¶</a></h3>
<p>Loom supports multiple layers. There is always a single main matrix, but
optionally one or more additional layers having the same number of rows
and columns. Layers are accessed using the <code class="docutils literal notranslate"><span class="pre">layers</span></code> property on the
<code class="docutils literal notranslate"><span class="pre">LoomConnection</span></code> object.</p>
<p>Layers support the same pythonic API as attributes:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ds</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>            <span class="c1"># Return list of layers</span>
<span class="n">ds</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;unspliced&quot;</span><span class="p">]</span>      <span class="c1"># Return the layer named &quot;unspliced&quot;</span>
<span class="n">ds</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;spliced&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># Create or replace the &quot;spliced&quot; layer</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;spliced&quot;</span><span class="p">][:,</span> <span class="mi">10</span><span class="p">]</span> <span class="c1"># Assign the 10th column of layer &quot;spliced&quot; to the variable a</span>
<span class="k">del</span> <span class="n">ds</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;spliced&quot;</span><span class="p">]</span>     <span class="c1"># Delete the &quot;spliced&quot; layer</span>
</pre></div>
</div>
<p>The main matrix is availabe as a layer named “” (the empty string). It cannot be deleted but
otherwise supports the same operations as any other layer.</p>
<p>As a convenience, layers are also available directly on the connection object. The above
expressions are equivalent to the following:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ds</span><span class="p">[</span><span class="s2">&quot;unspliced&quot;</span><span class="p">]</span>      <span class="c1"># Return the layer named &quot;unspliced&quot;</span>
<span class="n">ds</span><span class="p">[</span><span class="s2">&quot;spliced&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># Create or replace the &quot;spliced&quot; layer</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;spliced&quot;</span><span class="p">][:,</span> <span class="mi">10</span><span class="p">]</span> <span class="c1"># Assign the 10th column of layer &quot;spliced&quot; to the variable a</span>
<span class="k">del</span> <span class="n">ds</span><span class="p">[</span><span class="s2">&quot;spliced&quot;</span><span class="p">]</span>     <span class="c1"># Delete the &quot;spliced&quot; layer</span>
</pre></div>
</div>
<p>Sometimes you may need to create an empty layer (all zeros), to be filled later. Empty layers
are created by assigning a type to a layer name. For example:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ds</span><span class="p">[</span><span class="s2">&quot;empty_floats&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;float32&quot;</span>
<span class="n">ds</span><span class="p">[</span><span class="s2">&quot;empty_ints&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;int64&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="graphs">
<span id="loomoperations"></span><h3>Graphs<a class="headerlink" href="#graphs" title="Permalink to this headline">¶</a></h3>
<p>Loom supports sparse graphs with either the rows or the columns as nodes. For example,
a sparse graph of cells (stored in the columns) could represent a K nearest-neighbors
graph of the cells. In that case, the cells are the nodes (so there are M nodes in the
graph if there are M columns in the main matrix), which are connected by an arbitrary
number of edges. The graph could be considered directed or undirected, and can have float-valued
weights on the edges. Loom even supports multigraphs (permitting multiple edges between pairs of nodes).
Graphs are stored as arrays of edges and the associated edge weights.</p>
<p>Row and column graphs are accessed at <code class="docutils literal notranslate"><span class="pre">ds.row_graphs</span></code> and <code class="docutils literal notranslate"><span class="pre">ds.col_graphs</span></code>, respectively,
and support the same interface as attributes. For example:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ds</span><span class="o">.</span><span class="n">row_graphs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>      <span class="c1"># Return list of row graphs</span>
<span class="n">ds</span><span class="o">.</span><span class="n">col_graphs</span><span class="o">.</span><span class="n">KNN</span> <span class="o">=</span> <span class="o">...</span>   <span class="c1"># Create or replace the column-oriented graph KNN</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">col_graphs</span><span class="o">.</span><span class="n">KNN</span>     <span class="c1"># Assign the KNN column graph to variable a</span>
<span class="k">del</span> <span class="n">ds</span><span class="o">.</span><span class="n">col_graphs</span><span class="o">.</span><span class="n">KNN</span>     <span class="c1"># Delete the KNN graph</span>
</pre></div>
</div>
<p>Graphs are returned as <code class="docutils literal notranslate"><span class="pre">scipy.sparse.coo_matrix</span></code>, and can be created/assigned from any
scipy sparse format as well as from a numpy dense matrix or ndarray. In each case, the matrix
represents the adjacency matrix of the graph.</p>
</div>
<div class="section" id="views">
<h3>Views<a class="headerlink" href="#views" title="Permalink to this headline">¶</a></h3>
<p>Loompy views are in-memory views of a slice through the underlying loom file. Views can be created
explicitly by slicing:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ds</span><span class="o">.</span><span class="n">view</span><span class="p">[:,</span> <span class="mi">10</span><span class="p">:</span><span class="mi">20</span><span class="p">]</span>
</pre></div>
</div>
<p>This will create a view, fully loaded in memory, containing all the rows of the underlying loom file,
but only columns 10 through 19 (zero-based). You can use fancy indexing including slices, arrays of integers
(to pick out specific rows/columns) and boolean arrays.</p>
<p>The power of the view is that it slices through <em>everything</em>: the main matrix, every layer, every attribute,
and every graph. This hides a lot of messy and error-prone code,
and makes it easy to extract relevant subsets of a loom file.</p>
<p>The most common use of a <code class="docutils literal notranslate"><span class="pre">view</span></code> is in scanning through a file (see <code class="docutils literal notranslate"><span class="pre">scan()</span></code> below).</p>
</div>
<div class="section" id="operations">
<h3>Operations<a class="headerlink" href="#operations" title="Permalink to this headline">¶</a></h3>
<div class="section" id="map">
<h4>Map<a class="headerlink" href="#map" title="Permalink to this headline">¶</a></h4>
<p>You can map one or more functions across all rows (all columns), while avoiding
loading the entire dataset into memory:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ds</span><span class="o">.</span><span class="n">map</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The functions will receive an array (of floats or integers) as their only argument, and
should return a single float or integer value. Internally, <code class="docutils literal notranslate"><span class="pre">map()</span></code> uses <code class="docutils literal notranslate"><span class="pre">scan()</span></code> to
loop across the file.</p>
<p>Note that you must always provide a list of functions, even if it has only one element, and
that the result is a list of vectors, one per function that was supplied. Hence the correct
way to map a single function across the matrix is:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">means</span><span class="p">,)</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">map</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="permutation">
<h4>Permutation<a class="headerlink" href="#permutation" title="Permalink to this headline">¶</a></h4>
<p>Permute the order of the rows or columns:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ordering</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">ds</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="n">ordering</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>This permutes the order of rows or columns in the file, without loading
the entire file in RAM. The <code class="docutils literal notranslate"><span class="pre">ordering</span></code> argument should be a numpy array
of ds.shape[axis] elements, in the desired order.</p>
</div>
<div class="section" id="scan">
<h4>Scan<a class="headerlink" href="#scan" title="Permalink to this headline">¶</a></h4>
<p>For very large loom files, it’s very useful to scan across the file
(along either rows or columns) in <em>batches</em>, to avoid loading the entire
file in memory. This can be achieved using the <code class="docutils literal notranslate"><span class="pre">scan()</span></code> method:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">selection</span><span class="p">,</span> <span class="n">view</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
  <span class="c1"># do something with each view</span>
</pre></div>
</div>
<p>Inside the loop, you get access to the current <code class="docutils literal notranslate"><span class="pre">view</span></code> into the file. It has all the
attributes, graphs and data of the original loom file, but only for the columns included
in <code class="docutils literal notranslate"><span class="pre">selection</span></code> (or rows, if axis=0).</p>
<p>In essence, you get a succession of slices through the loom file, corresponding to
bands of columns (rows). The <code class="docutils literal notranslate"><span class="pre">ix</span></code> variable tells you the starting column of the band, whereas
the <code class="docutils literal notranslate"><span class="pre">selection</span></code> gives you the list of columns contained in the current view.</p>
<p>You can also scan across a selected subset of the columns or rows. For example:</p>
<div class="code python highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cells</span> <span class="o">=</span> <span class="c1"># List of columns you want to see</span>
<span class="k">for</span> <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">selection</span><span class="p">,</span> <span class="n">view</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="n">items</span><span class="o">=</span><span class="n">cells</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
  <span class="c1"># do something with each view</span>
</pre></div>
</div>
<p>This works exactly the same, except that each <code class="docutils literal notranslate"><span class="pre">selection</span></code> and <code class="docutils literal notranslate"><span class="pre">view</span></code> now include only
the columns you asked for.</p>
</div>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017, LinnarssonLab.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.0+/da40971.<br/>
    </p>
  </div>
</footer>
  </body>
</html>